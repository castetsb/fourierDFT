# -*- coding: utf-8 -*-
"""
Created by Benoit CASTETS
15/3/2018
Pratical usage of the Fourier Discret Transform
1)Find the note (frequency) of a piano key form its recording
2)Filter harmonics to remove background noise
"""

#Libraries used to work on this exercice
import numpy as np
from matplotlib import pyplot as plt
import scipy.ndimage as ndimage
from scipy.io import wavfile

##############################################################
#1)Find the note (frequency) of a piano key form its recording
##############################################################

#a) Load and characterise sound recording
#########################################

#Load sound recording values (Numerical sequence)
fs, y = wavfile.read("re_octave2_146-83hz.wav")

#Numerical sequence characteristics
L=1.393#seconde
N=y.size

#Abcisse values (time in seconde)
x=np.linspace(0,L,N)

#Plot the sound recording as an introduction
plt.plot(x,y)
plt.title("Sound recording of a piano key")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.show()

#b) Find the frequency of DFT maximum
#####################################
#Apply DFT on y values
fft=np.fft.fft(y)
#Calculate DFT absolute
fftAbs=np.absolute(fft)
#Change data type form complex to float
fftAbs=fftAbs.astype(np.float)

#Calculate the maximum frenquency which can be analyzed with DFT
mShannon=int(N//2)
fShannon=mShannon/L

#Calculate sinusoid amplitude
sinusoidAmp=2*fftAbs[:mShannon]/N

#Change from mode to frequency
n=np.arange(0,N,1)
m=n
f=m/L

#Plot DFT output and reformated sinusoids amplitude
plt.subplot(1,2,1)
plt.title("DFT output")
plt.xlabel("Mode")
plt.ylabel("Amplitude")
plt.plot(fftAbs)
plt.subplot(1,2,2)
plt.title("Sinusoids amplitude")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Amplitude")
plt.plot(f[1:mShannon],sinusoidAmp[1:mShannon])
plt.show()

#We will focus on the range of frequencies generated by a piano
#with 5 octave [32.7Hz,1975.53Hz]
fMax=2000#hz
mMax=int(L*fMax)

#Zoom on frequency range [0,2000]
plt.title("Sinusoids amplitude [0,2000Hz]")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Amplitude")
plt.plot(f[1:mMax],sinusoidAmp[1:mMax])
plt.show()

#Search the frequency of DFT maximum (main frequency) which is the note of
#the piano key

#Main mode
mMain=np.argmax(fft[1:mShannon])
#Main frequency
fMain=mMain/L

print("The frequency of the piano key note is {}".format(fMain))

#c) Filter harmonics
####################
#The distance between 2 harmonic pics is equal the main frequency
#Knowing that we could apply a maximum filter with size of twice the main
#frequency but as a safety we will use a filter of (3/2)*(main frequency)

#Local maximum filter
filterSize=int(((mMain*1.5)//2)*2+1)
fftMaxFilter=ndimage.filters.maximum_filter1d(fftAbs,filterSize)

#Mask egale to True on harmonic position
harmonicMask=(fftMaxFilter==fftAbs)

#Apply harmonicMask on the FFT to filter harmonics
fftFiltered=fft*harmonicMask
#Remove mode 0
fftFiltered[0]=0

#Plot harmonic filtered DFT absolute
plt.subplot(2,1,1)
plt.title("DFT output. Mode [0,{}]".format(mMax))
plt.xlabel("Mode")
plt.ylabel("Amplitude")
plt.plot(np.absolute(fft)[:mMax])
plt.subplot(2,1,2)
plt.title("Harmonics filtered DFT. Mode [0,{}]".format(mMax))
plt.xlabel("Mode")
plt.ylabel("Amplitude")
plt.plot(np.absolute(fftFiltered)[:mMax])
plt.show()

#Rebuild sound values from filtered DFT using IDFT
filteredY=np.fft.ifft(fftFiltered)
#Take the real part of IDFT result
filteredY=np.real(filteredY)
#Abjust value amplitude to fit 16bit format
filteredY=(filteredY/np.max(filteredY))*0.5*((2**16)/2)

#Calculate original sound amplitude envelop to apply it on the filtered
#sound

#Maximum filter size is set at 2 time the main sinusoid period
filterSize=int(((2*(1/fMain)/(L/N))//2)*2+1)
envelop=ndimage.filters.maximum_filter1d(y,filterSize)
#Normalize the envelop to have a maximum amplitude of 1
envelop=envelop/np.max(envelop)

#plot sound magnitude envelop
plt.title("Sound amplitude envelop")
plt.xlabel("n")
plt.ylabel("Amplitude")
plt.plot(y/np.max(y))
plt.plot(envelop)
plt.plot(-envelop)
plt.show()

#Apply envelop on the filtered signal
filteredY=filteredY*envelop
#Convert to integer 16bit format for saving
filteredY=filteredY.astype(np.int16)

#Plot initiol and filtered sound values
plt.subplot(2,1,1)
plt.title("Original sound values")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.plot(x,y)
plt.subplot(2,1,2)
plt.title("Filtered sound values")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.plot(x,filteredY)
plt.show()

#Save filtered sound values in a wav file
samplingRate=int(N/L)#Samples/second
wavfile.write("output.wav",samplingRate,filteredY)